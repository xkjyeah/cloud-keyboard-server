<html>
<!--
 * WiFi Keyboard - Remote Keyboard for Android.
 * Copyright (C) 2011 Ivan Volosyuk
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 -->
<head>
  <!-- Todo list:
     - Latency display enable.
     - Support fo chinese input method, need to figure out how to deal with it
     - TextField mode
     - 

    -->
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>WiFi Keyboard</title>
  <script language="JavaScript">
   if (typeof XMLHttpRequest == "undefined")
     XMLHttpRequest = function () {
       try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); }
       catch (e) {}
       try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); }
       catch (e) {}
       try { return new ActiveXObject("Msxml2.XMLHTTP"); }
       catch (e) {}
       //Microsoft.XMLHTTP points to Msxml2.XMLHTTP.3.0 and is redundant
       throw new Error("This browser does not support XMLHttpRequest.");
   };

    // format: /seq,code,press/5012,32,1/
    ignore_next_char = false;
    repeat_key_code = "-1";

    seqConfirmed = 12345;
    seqPressed = seqConfirmed;
	
	// Sequence number is just used to collect replies
	seqNumber = parseInt(Math.random() * 10000);
    events = [];
    num_inflight = 0;
    num_delayed = 0;
    latency = 0;
    latency2 = 0;
    latencyTime = 0;
    latencyTime2 = 0;
    displayState = "loading";
    stat = null;
    inp = null;
    typed_chars = 0;


    function onConfirm(newConfirmed) {
		/*if (newConfirmed == seqPressed) {
			events = []; // clear events
		}
		if (newConfirmed <= seqConfirmed) return;
		for (i = seqConfirmed; i < newConfirmed; i++) {
			events[i] = undefined;
			seqConfirmed = newConfirmed;
		}*/
		network();
    }

    function queue(code, mode) {
		ev = mode + code;
		
		// TODO: Do we really want a sequence number?
		events.push( { 'type': 'key', 'data': ev } );
//      var el = document.getElementById("keys");
//      el.innerHTML = el.innerHTML + ' send:' + mode + code + " ";
    }

    function send(code, mode) {
		queue(code, mode);
		network();
    }
	
	/* Sends keypresses that have not been sent yet */
    function network() {
		var send_data = [];
		
		if (events.length == 0) return;
		if (num_inflight > 0) return;
		
		// else copy the first 100 into a new Array
		for (var i=0; i<events.length && i<100; i++) {
			send_data.push(events.shift());
		}
		
		makeXhr({ 'events': send_data });
    }

    function compat() {
      return !document.f.mode[0].checked;
    }

    function is_special(code) {
		if (code <= 40) {
			if (code >= 33) return true;
			if (code == 8 || code == 9 || code == 13 || code == 27) return true;
			if (code >= 16 && code <= 20) return true;
		} else {
			if (code == 42 || code == 45 || code == 46 || code == 93 || code == 145) return true;
			if (code >= 112 && code <= 123) return true;
		}
		return false;
    }
    function keyevent(key, mode) {
		if (compat()) {
			ignore_next_char = mode == 'D';
			repeat_key_code = key;
			send(key, mode);
			return false;
		}
		if (is_special(key)) {
			ignore_next_char = mode == 'D';
			repeat_key_code = key;
			send(key, mode);
			return false;
		}
		ignore_next_char = false;
		return true;
    }

    function update_input() {
		typed_chars++;
    }

    function examine_input() {
		if (inp == null) {
			inp = document.getElementById("in");
		}
		if (inp == null) {
			typed_chars = 0;
			return;
		}
		var val = inp.value;
		if (val.length == 0) {
			typed_chars = 0;
			return;
		}

		// if not paste and not chinese
		if (val.length <= typed_chars
		&& val.charCodeAt(0) < 128) {
			return;
		}
		for (i = 0; i < val.length; i++) {
			queue(val.charCodeAt(i), 'C');
		}
		typed_chars = 0;
		inp.value = "";
		network();
    }

    function up(e) {
      examine_input();
      if (!e) e = window.event;
      return keyevent(e.keyCode, 'U');
    }
    function down(e) {
      update_input();
      if (!e) e = window.event;
      if (e.keyCode == 115) {
        no_input();
        recv_text();
        return false;
      }
      return keyevent(e.keyCode, 'D');
    }
    function press(e) {
      if (ignore_next_char) {
         ignore_next_char = false;
         return false;
      }
      if (compat()) return false;
      if (!e) e = window.event;
      if (e.charCode != undefined) {
        ch = e.charCode;
      } else {
        ch = e.keyCode;
      }

      // firefox and opera hack
      if (ch == 0 || ch == repeat_key_code) {
        send(repeat_key_code, 'D');
        return false;
      }
      send(ch, 'C');
      return false;
    }
    function focus_me() {
      document.getElementById("in").focus();
    }

    function setDisplayState(newState) {
      if (newState == displayState) return;
      displayState = newState;

      if (stat == null) {
        stat = document.getElementById("status");
        xcomment = document.getElementById("comment");
      }
      if (stat == null) return;

      if (newState == "connected") {
        stat.innerHTML = "Connected";
        stat["color"] = "green";
        xcomment.innerHTML = "You can type now.";
      } else if (newState == "failure") {
        stat.innerHTML = "Connection problem";
        stat["color"] = "red";
        xcomment.innerHTML = "No connection between the phone and computer.";
      } else if (newState == "problem") {
        stat.innerHTML = "Not typing";
        stat["color"] = "red";
        xcomment.innerHTML = 'Enable WiFiKeyboard input on you device. <a href="http://code.google.com/p/wifikeyboard/wiki/WiFiKeyboardSettings">Visit help page.</a>';
      } else if (newState == "multi") {
        stat.innerHTML = "Mutiple input";
        stat["color"] = "red";
        xcomment.innerHTML = "Typing from multiple browser windows is not supported. Use one browser window.";
      }
    }
	
	/** If receive an error, repeat the request. Otherwise
		handle each returning input. For each reply, if there
		is a sequence number, call the callback associated with
		the sequence number.
	*/
	var seqCallbacks = {};
	
	function manageDisplayStatus(replies) {
		var lastStatus = 'connected';
		
		for (var i=0; i<replies.length; i++) {
			switch (replies[i].result) {
			case 0:			// success
				lastStatus = 'connected';
				break;
			case 1:
			default:
				lastStatus = 'problem';
				break;
			}
			
		}		
		setDisplayState(lastStatus);
	}
	
	function manageCallbacks(replies) {
		for (var i=0; i<replies.length; i++) {
		
			var seq;
			if ( (seq = replies[i].seq) ) {
				console.log("callback for " + seq);
				seqCallbacks[seq](replies[i]);
				delete seqCallbacks[seq]; // delete
			}
			
		}
	}
	
	function xhrHandler(xhr, data, callback) {
		return function() {
			if (xhr.readyState != 4) return;
			
			if (xhr.status != 200) {
				setDisplayState('failure');
				setTimeout(
					function() {makeXhrRequest(data)},
					2000);
			}
			else {
				var reply = JSON.parse(xhr.responseText);
				var lastStatus = 'connected';
				
				console.log(xhr.responseText);
				
				manageDisplayStatus(reply.replies);
				manageCallbacks(reply.replies);
			}
		};
	}
	
	function makeXhrRequest(data, callback, retry) {
	    var submitter = new XMLHttpRequest();
	
		console.log(data);
		submitter.onreadystatechange = xhrHandler(submitter, data, retry);
		submitter.open('POST', "/clients/key", true);
        submitter.setRequestHeader("Content-type", "application/json");
        submitter.send(data);
	}
	
	// Send keypress messages
	// Unlike makeXhrRequest, this one rate limits itself
	function makeXhr(send_data) {
	
		// TODO: if there is an error, logically I will
		// want to append more keys to it instead of
		// replying with the original input, to maximize
		// the throughput
		/*
		if (send_data.events.length > 0) {
			send_data.events[ send_data.events.length - 1]['seq'] = seqNumber;
			seqCallbacks[seqNumber] = function(dt) {
				onConfirm();
			};
		}*/
		
		var xhr = new XMLHttpRequest();
		
		num_inflight++;
	
		console.log(send_data);
		xhr.onreadystatechange = function() {
			if (xhr.readyState != 4) return
			
			num_inflight--;;
			
			if (xhr.status != 200) {
				setDisplayState('failure');
				
				// FIXME: this WILL reorder requests
				// if I start typing in between fialures
				setTimeout(
					function() {makeXhr(send_data)},
					2000);
			}
			else {
				var reply = JSON.parse(xhr.responseText);
				console.log(xhr.responseText);
				
				manageDisplayStatus(reply.replies);
				manageCallbacks(reply.replies);
        
        // if there are more characters in buffer, send them out!
        network();
			}
		};
		
		xhr.open('POST', "/clients/key", true);
        xhr.setRequestHeader("Content-type", "application/json");
        xhr.send(JSON.stringify(send_data));
    }


    function submit_text() {
        var params = document.getElementById("in").value;
		var send_data = JSON.stringify({
			'events': [
				{'type': 'settext', 'data': params, 'seq': seqNumber}
			]
		});
		
		seqCallbacks[seqNumber] = function(dt) {
			// set text successful!
			document.getElementById('in').value = "";
			direct_input();
		};
		makeXhrRequest(send_data);
		poll();
		seqNumber++;
      }
	  
    function recv_text() {
        var recvText = new XMLHttpRequest();
        recvText.onreadystatechange = function() {
			if (recvText.readyState != 4) return;
			if (recvText.status != 200) {
				// FIXME: error handling
				setTimeout("recv_text();", 2000);
			}
			if (recvText.responseText != undefined) {
				var recvData = JSON.parse(recvText.responseText);
				document.getElementById('in').value = recvData.replies[0].data;
				local_input();
			}
        }
		var send_data = JSON.stringify( {
			'events': [
				{ 'type' : 'gettext', 'seq': seqNumber }
			]
		});
		makeXhrRequest(send_data);
		seqCallbacks[seqNumber] = function(data) {
			// get text successful
			document.getElementById('in').value = data['data'];
			local_input();
		};
		poll();
		seqNumber++;
    }
	
	function poll() {
		var waitingCallback = Object.keys(seqCallbacks).length > 0;
		
		if (waitingCallback) {
			makeXhrRequest(JSON.stringify( {
				'events': []
			} ));
			setTimeout(poll, 2000);
		}
	}

    function direct_input() {
        var x = document.getElementById("in");
        x.onkeydown = down;
        x.onkeyup = up;
        x.onkeypress = press;
        window.onblur = function() {
            send(1024,'D');
            focus_me();
        }
        window.onfocus = focus_me;
        window.onmouseup = function() {
            setTimeout(examine_input, 10);
        };
        window.onmouseover = function() {
            setTimeout(examine_input, 10);
        };
        n = document.getElementById("in");
        n.style.backgroundColor = "#f1f1ed";
        n.value = "";
        
    }

    function no_input() {
        document.getElementById("in").style.backgroundColor = "#f1e1cd";
        var x = document.getElementById("in");
        x.onkeydown = function(e) { return false; }
        x.onkeypress = function() { return false; }
        x.onkeyup = function() { return false; }
        window.onblur = function() {}
        window.onmouseup = function() {};
        window.onmouseover = function() {};
    }

    function local_input() {
        document.getElementById("in").style.backgroundColor = "#FFFFFF";
        var x = document.getElementById("in");
        x.onkeydown = function(e) {
            if (!e) e = window.event;
            if (e.keyCode == 115) {
                submit_text();
                no_input();
                return false;
            }
          return true;
        }
        x.onkeypress = function() { return true; }
        x.onkeyup = function() { return true; }
    }


    function loadFinished() {
      focus_me();
      send(1024, 'D');
      direct_input();
    }
    window.onload = loadFinished;
</script>
<link rel="icon" type="image/png" href="/icon.png" />
<style type="text/css">
   h1 {
    font-size: 30px;
   } 
   .wf-active h1 {
    font-family: 'Cantal', arial, serif;
   }
   h2 {
    font-size: 20px;
   }
   .wf-active h2 {
    font-family: 'Yanone Kaffeesatz', arial, serif; 
   }
   div {
    font-size: 15px;
    padding: 3px;
   }
   .wf-active div {
    font-family: 'Droid Sans', arial, serif;
   }

   div.footer {
    font-family: arial, serif;
    font-size: 20px;
    text-align: right;
   }
   
   body {
    color:#000000;
    background-color:#f1f1ed;
    margin:0px;
    overflow:auto;
   }
   table.main {
     width:800px;
     margin-top:0px;
     margin-bottom:0px;
     background-color:#ffffff;
     padding:15px;
     background-image:url('bg.gif');
     background-repeat:repeat-x;
     height: 100%;
   }
</style>
</head>
<body id="myBody">

<div style="font-size:150%">
  <a href="/clients/logout">Log out</a>
</div>

<div>
	<form method="POST" action="clients/key">
	<input type="text" name="p" value="v" />
	
	<input type="submit" />
	
	</form>
</div>

<table class="main" align="center">
<tbody>
<tr valign="top">
<td class="main" width="450">
<!-- Main Window -->
<h1>WiFi&nbsp;Keyboard</h1>
  <table border="0"><tbody><tr><td cellspacing="50" cellpadding="50">
  <form name="f">
  <h2>Keyboard mode:</h2>
  <div class="mode"><input type="radio" name="mode" value="i" checked>International keyboard</div>
  <div class="mode"><input type="radio" name="mode" value="c">Game mode (key codes only)</div>
  </form>
  </td></tr></tbody></table>

<!-- Main Window End -->
</td>
<td width="450">
  <table border="0"><tbody><tr><td cellspacing="50" cellpadding="50">
  <tr>
  <td>
  <h2>Special keys:</h2>
  <ul>
  <li>Shift = Shift</li>
  <li>Alt = Alt</li>
  <li>Arrows = DPAD Arrows</li>
  <li>Insert or F1 = DPAD Center</li>
  <li>F2 = Menu</li>
  <li>F3 = Search</li>
  <li>Escape,F5 = BACK</li>
  <li>F9, F10 = Volume control</li>
  <li><font color="red">F4 = Edit locally/ submit (alpha)</font></li>
  </ul>
  </td></tr></tbody></table>
</td>
<td align="right" width="200">
<!-- Side bar -->
  <table border="1" cellpadding="20"><tbody><tr><td cellspacing="50" cellpadding="50">
  <h2>Status: <font color="black" id="status">Connecting...</font></h2>
  <div id="comment"></div>
  </td></tr></tbody></table>

  <br>
</td>
</tr>
<tr>
<td colspan="3">
  <h2>Android input (type or paste here):</h2>
  <form method="post" action="/form">
      <input type="hidden" name="name" value="value">
      <textarea name="text" cols="100" rows="20" id="in"></textarea>
  </form>

</td>
</tr>
<tr>
<td colspan="3">
  <div class="footer"><a href="http://code.google.com/p/wifikeyboard/">Source code available (license GPL v2).</a><br>Created by Ivan Volosyuk on 2010.</div>
<!-- <div id="keys">Debug: key presses:</div> -->
<!-- <div id="debug">New event placeholder.</div> -->
<td>
</tr>
</tbody>
</table>
</body>
</html>
